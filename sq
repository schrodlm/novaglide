[1mdiff --git a/docker-compose.yaml b/docker-compose.yaml[m
[1mindex 0d9257c..5719054 100644[m
[1m--- a/docker-compose.yaml[m
[1m+++ b/docker-compose.yaml[m
[36m@@ -9,7 +9,7 @@[m [mservices:[m
       - POSTGRES_HOST=postgres[m
       - POSTGRES_DB=novaglide_db[m
     volumes:[m
[31m-      - ./pgdata:/var/lib/postgresql/data[m
[32m+[m[32m      - "/pgdata:/var/lib/postgresql/data"[m
     ports:[m
       - 5432:5432[m
   adminer:[m
[1mdiff --git a/src/game.py b/src/game.py[m
[1mindex e60d28c..6a4c258 100644[m
[1m--- a/src/game.py[m
[1m+++ b/src/game.py[m
[36m@@ -87,6 +87,7 @@[m [mclass Game():[m
             self.check_inputs()[m
             self.share_inputs()[m
             match_data = self.share_inputs()["data"][m
[32m+[m[41m        [m
         #match_stats = curr_match.get_match_stats()[m
         self.play_match = False[m
         #self.curr_menu = EndScreenMenu(self, match_stats)[m
[1mdiff --git a/src/main.py b/src/main.py[m
[1mindex 4dc9783..40eb73e 100644[m
[1m--- a/src/main.py[m
[1m+++ b/src/main.py[m
[36m@@ -18,6 +18,7 @@[m [mclass Client:[m
                 self.g.status = "ingame"[m
                 self.g.start_match(response["data"])[m
                 self.g.play_match = False[m
[32m+[m
             if self.g.play_match is True:[m
                 server_reply = self.g.net.send(self.g.parse_data("queued_solo",["no_data"]))[m
                 self.g.status = "Waiting_for_opponent"[m
[36m@@ -26,6 +27,7 @@[m [mclass Client:[m
                     self.g.status = "ingame"[m
                     self.g.start_match(server_reply["data"])[m
                     self.g.play_match = False[m
[32m+[m
             [m
             [m
 [m
[1mdiff --git a/src/match/match.py b/src/match/match.py[m
[1mindex f6fe006..67a431f 100644[m
[1m--- a/src/match/match.py[m
[1m+++ b/src/match/match.py[m
[36m@@ -142,6 +142,7 @@[m [mclass Match1v1(Match):[m
         [m
     def update_player_2(self, inputs):[m
         self.p2.update(self.dt, None, inputs[0], self.elapsed_time, inputs[1], inputs[2])[m
[32m+[m[41m    [m
     def end_match(self):[m
         #TODO: has  to return all the stats to the[m
         # Determine the winner based on the score[m
[1mdiff --git a/src/server.py b/src/server.py[m
[1mindex c402df5..22dcea3 100644[m
[1m--- a/src/server.py[m
[1m+++ b/src/server.py[m
[36m@@ -95,6 +95,7 @@[m [mclass Server:[m
                     print("match already removed")[m
                 print("Curent matches: ", self.matches)[m
                 break[m
[32m+[m
     def threaded_client(self, conn):[m
         #send client his id[m
         conn.send(str.encode(str("Welcome, please fill the credentials!")))[m
[36m@@ -193,8 +194,11 @@[m [mclass Server:[m
             else:[m
                 self.queued_solo_players.add(int(message["sender"]))[m
                 return self.create_packet("Waiting_for_opponent",["no_data"])[m
[32m+[m[41m            [m
         if message["flag"] == "ingame":[m
             return self.stream_match(message)[m
[32m+[m[41m        [m
[32m+[m[32m        #if message["flag"] == "get_match_stats":[m
 [m
     def stream_match(self, message):[m
         for match in self.matches:[m
